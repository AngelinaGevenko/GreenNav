<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-map/google-map.html">
<link rel="import" href="../google-map/google-map-poly.html">
<link rel="import" href="../google-map/google-map-point.html">
<link rel="import" href="../google-map/google-map-marker.html">
<link rel="import" href="../osm-map/osm-map.html">
<link rel="import" href="../osm-map/osm-poly.html">
<link rel="import" href="../osm-map/osm-point.html">
<link rel="import" href="../osm-map/osm-marker.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<!--
    
The `gn-map` element provides a wrapper for different map types.
If attribute map-type change, the changes will apply to all child elements.
At this time `gn-map` supports `google-map` and `osm-map` and all
children like polygons, points and markers.

Examples:

    <gn-map
      longitude="9.45"
      latitude="38.24"
      zoom="13"
      map-type="GoogleMap">
    </gn-map>

    <gn-map
      longitude="9.45"
      latitude="38.24"
      zoom="13"
      map-type="OpenStreetMap">
    </gn-map>

By default `map-type="GoogleMap"`

@demo
-->

<dom-module id="gn-map">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
      }

      google-map /deep/ .gm-style-iw {
        text-align: center;
      }
    </style>

    <!-- <template id="osmMap" is="dom-if" if="{{_typeIsOpenStreetMap(mapType)}}">
      <osm-map longitude="{{longitude}}" latitude="{{latitude}}" zoom="{{zoom}}">
        <template is="dom-repeat" items="{{polygons}}">
          <osm-poly fill-opacity="{{item.fillOpacity}}" stroke-color$="{{item.strokeColor}}" width$="{{item.width}}" closed$="{{item.closed}}" fill-color$="{{item.fillColor}}">
            <template is="dom-repeat" items="{{item.points}}">
              <osm-point longitude$="{{item.longitude}}" latitude$="{{item.latitude}}"></osm-point>
            </template>
          </osm-poly>
        </template>
        <template is="dom-repeat" items="{{markers}}">
          <osm-marker longitude$="{{item.longitude}}" latitude$="{{item.latitude}}"></osm-marker>
        </template>
      </osm-map>
    </template> -->

    <!-- <template is="dom-if" if="{{_typeIsGoogleMap(mapType)}}"> -->
      <google-map id="googleMap" longitude="{{longitude}}" latitude="{{latitude}}" zoom="{{zoom}}" drag-events>
        <template is="dom-repeat" items="{{polygons}}">
          <google-map-poly fill-opacity="{{item.fillOpacity}}" stroke-color$="{{item.strokeColor}}" width$="{{item.width}}" closed$="{{item.closed}}" fill-color$="{{item.fillColor}}">
            <template is="dom-repeat" items="{{item.points}}">
              <google-map-point longitude$="{{item.longitude}}" latitude$="{{item.latitude}}"></google-map-point>
            </template>
          </google-map-poly>
        </template>
        <template is="dom-repeat" items="{{markers}}">
          <google-map-marker longitude$="{{item.longitude}}" latitude$="{{item.latitude}}"></google-map-marker>
        </template>  
      </google-map>
    <!-- </template> -->

    <iron-ajax
      id="weatherAjax"
      url="[[requestString]]"
      handle-as="json"
      on-response="processResults"
      debounce-duration="300">
    </iron-ajax>

    <content></content>
  </template>
<script>
  Polymer({
    is: 'gn-map',

    properties: {
      /**
       * A latitude to center the map on.
       */
      latitude: {
        type: Number,
        notify: true,
        value: 53.834089,
        reflectToAttribute: true
      },

      /**
       * A longitude to center the map on.
       */
      longitude: {
        type: Number,
        notify: true,
        value: 10.703718,
        reflectToAttribute: true
      },

      /**
       * A zoom level which will be applied to the map.
       */
      zoom: {
        type: Number,
        value: 11,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * The map-type is bind by dom-if template to include different type of maps
       * Possible values are "GoogleMap" or "OpenStreetMap".
       */
      mapType: {
        type: String,
        value:"GoogleMap",
        notify: true
      },

      /**
       * Holds the map object and allows to modify values during runtime
       */
      map: {
        type: Object
      },

      /**
       * Array of polygon objects
       */
      polygons: {
          type: Array,
          notify: true,
          value: function () {
            return [];
          }
      },

      /**
       * Array of Marker objects
       */
      markers: {
          type: Array,
          notify: true,
          value: function () {
            return [];
          }
      },

      /**
       * Array of user created Polygons
       */
      _userPolygons: {
        type: Array,
        notify: true,
        value: function () {
          return [];
        }
      },

      /**
       * Array of user created Markers
       */
      _userMarkers: {
        type: Array,
        notify: true,
        value: function () {
          return [];
        }
      }
    },

    attached: function () {
      var self = this;
      this.addEventListener('update-gn-map', function () {
          self.splice('polygons', -1);
          self.splice('markers', -1);

          self.queryAllEffectiveChildren('gn-poly').forEach(function (polygon) {
            self.push('polygons', polygon.asObject());
          });
          self._userPolygons.forEach(function (polygon) {
            self.push('polygons', polygon);
          });

          self.queryAllEffectiveChildren('gn-marker').forEach(function (marker) {
            self.push('markers', marker.asObject());
          });
          self._userMarkers.forEach(function (marker) {
            self.push('markers', marker);
          });
      });    

      // Make sure to keep the "global" Polymer context to be able to call methods from inner functions.
      var ctx = this;
      ctx.gmap = document.querySelector('google-map');

      // Initial weather request begins here
      ctx.gmap.addEventListener('api-load', function(e) {
        ctx.checkIfDataRequested();
        ctx.addMapListeners();
      });
    },

    checkIfDataRequested: function() {
      while (this.gettingData === true) {
        var requests = this.$.weatherAjax.activeRequests;
        if (requests.length > 0) {
          requests.forEach(function(request) {
            request.abort();
          });
        }
        this.gettingData = false;
      }
      this.getCoords();
    },

    addMapListeners: function() {
      var ctx = this;
      ctx.gmap.map.addListener('idle', function() {
        ctx.checkIfDataRequested();
      });
      ctx.gmap.map.data.addListener('click', function(event) {
        // Close the previous infowindow if it exists.
        if (this.infowindow) {
          this.infowindow.close();
        }
        this.infowindow = new google.maps.InfoWindow();
        this.infowindow.setContent(
          "<img src=" + event.feature.getProperty("icon") + ">" +
          "<br /><strong>" + event.feature.getProperty("city") + "</strong>" +
          "<br />" + event.feature.getProperty("temperature") + "&deg;C" +
          "<br />" + event.feature.getProperty("weather")
        );
        this.infowindow.setOptions({
          position:{
            lat: event.latLng.lat(),
            lng: event.latLng.lng()
          },
          pixelOffset: {
            width: 0,
            height: -15
          }
        });
        this.infowindow.open(ctx.gmap.map);
      });
    },

    getCoords: function() {
      // Make sure to keep the "global" Polymer context to be able to call methods from inner functions.
      var ctx = this;

      // @TODO: find the google-map event that fires last and call getBounds at that time.
      // Without setTimeout getBounds returns null.
      setTimeout(function() {
        var bounds = ctx.gmap.map.getBounds();
        var NE = bounds.getNorthEast();
        var SW = bounds.getSouthWest();
        ctx.getWeather(NE.lat(), NE.lng(), SW.lat(), SW.lng());
      }, 500);
    },

    getWeather: function(northLat, eastLng, southLat, westLng) {
      // @TODO: Stop extra requests being sent
      this.gettingData = true;

      var openWeatherMapKey = "733446808ddd15de03a2fa4d46e5e17e";
      this.requestString = "http://api.openweathermap.org/data/2.5/box/city?bbox="
                          + westLng + "," + northLat + "," //left top
                          + eastLng + "," + southLat + "," //right bottom
                          + this.gmap.map.getZoom()
                          + "&cluster=yes&format=json"
                          + "&APPID=" + openWeatherMapKey;
      this.$.weatherAjax.generateRequest();
    },

    processResults: function(e) {
      var ctx = this;
      var results = e.detail.response.list;

      if (results.length > 0) {
        this.resetData();
        results.forEach(function(result) {
          ctx.geoJSON.features.push(ctx.jsontoGeoJson(result));
        });
        this.drawIcons();
      }
    },

    resetData: function() {
      var ctx = this;
      ctx.geoJSON = {
        type: "FeatureCollection",
        features: []
      };
      
      // Clean up the cache
      ctx.gmap.map.data.forEach(function(feature) {
        ctx.gmap.map.data.remove(feature);
      });
    },

    jsontoGeoJson: function(weatherItem) {
      var feature = {
        type: "Feature",
        properties: {
          city: weatherItem.name,
          weather: weatherItem.weather[0].main,
          temperature: weatherItem.main.temp,
          min: weatherItem.main.temp_min,
          max: weatherItem.main.temp_max,
          humidity: weatherItem.main.humidity,
          pressure: weatherItem.main.pressure,
          windSpeed: weatherItem.wind.speed,
          windDegrees: weatherItem.wind.deg,
          windGust: weatherItem.wind.gust,
          icon: "http://openweathermap.org/img/w/"
                + weatherItem.weather[0].icon  + ".png",
          coordinates: [weatherItem.coord.lon, weatherItem.coord.lat]
        },
        geometry: {
          type: "Point",
          coordinates: [weatherItem.coord.lon, weatherItem.coord.lat]
        }
      };
      // Set the custom marker icon
      this.gmap.map.data.setStyle(function(feature) {
        return {
          icon: {
            url: feature.getProperty('icon'),
            anchor: new google.maps.Point(25, 25)
          }
        };
      });

      // returns object
      return feature;
    },

    drawIcons: function() {
      this.gmap.map.data.addGeoJson(this.geoJSON);
      this.gettingData = false;
    },

    addPolygon: function (points, strokeColor, width, closed, fillColor, fillOpacity) {
      points = (typeof points === 'undefined') ? [] : points;
      strokeColor = (typeof strokeColor === 'undefined') ? '#0091ea' : strokeColor;
      width = (typeof width === 'undefined') ? 4 : width;
      closed = (typeof closed === 'undefined') ? false : closed;
      fillColor = (typeof fillColor === 'undefined') ? '#00960a' : fillColor;
      fillOpacity = (typeof fillOpacity === 'undefined') ? '0.5' : fillOpacity;

      polygon = {
        strokeColor: strokeColor,
        width: width,
        closed: closed,
        fillColor: fillColor,
        points : points,
        fillOpacity : fillOpacity
      }

      this.push('_userPolygons', polygon);
      this.fire('update-gn-map');
    },

    addMarker: function (latitude, longitude) {
      this.push('_userMarkers', {
        longitude: Number(longitude),
        latitude: Number(latitude)
      });
      this.fire('update-gn-map');
    },

    _typeIsOpenStreetMap: function (mapType) {
        return mapType === 'OpenStreetMap';
    },

    _typeIsGoogleMap: function (mapType) {      
        return mapType === 'GoogleMap';
    }
  });
</script>

</dom-module>